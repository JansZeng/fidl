// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of core;

typedef void ErrorHandler(FidlEventHandlerError error);

class FidlEventHandler {
  static const int _kSignals = MX_SIGNAL_READABLE | MX_SIGNAL_PEER_CLOSED;

  Channel _channel;
  FidlEventSubscription _subscription;
  bool _isOpen = false;
  bool _isInHandler = false;
  bool _isPeerClosed = false;

  FidlEventHandler.fromChannel(Channel channel,
                                {bool autoBegin: true})
      : _channel = channel,
        _subscription = new FidlEventSubscription(channel.handle, _kSignals) {
    if (autoBegin) {
      beginHandlingEvents();
    }
  }

  FidlEventHandler.fromHandle(Handle handle, {bool autoBegin: true})
      : _channel = new Channel(handle),
        _subscription = new FidlEventSubscription(handle, _kSignals) {
    if (autoBegin) {
      beginHandlingEvents();
    }
  }

  FidlEventHandler.unbound();

  /// The event handler calls the [handleRead] method when the underlying Mojo
  /// message pipe channel has a message available to be read. Implementers
  /// should read, decode, and handle the message. If [handleRead] throws
  /// an exception derived from [Error], the exception will be thrown into the
  /// root zone, and the application will end. Otherwise, the exception object
  /// will be passed to [onError] if it has been set, and the exception will
  /// not be propagated to the root zone.
  void handleRead() {}

  /// Like [handleRead] but indicating that the underlying message pipe channel
  /// is ready for writing.
  void handleWrite() {}

  /// Called when [handleRead] or [handleWrite] throw an exception generated by
  /// Mojo library code. Other exceptions will be re-thrown.
  ErrorHandler onError;

  Channel get channel => _channel;
  bool get isOpen => _isOpen;
  bool get isInHandler => _isInHandler;
  bool get isBound => _channel != null;
  bool get isPeerClosed => _isPeerClosed;

  void bind(Channel channel) {
    if (isBound) {
      throw new FidlApiError("FidlEventHandler is already bound.");
    }
    _channel = channel;
    _subscription = new FidlEventSubscription(channel.handle, _kSignals);
    _isOpen = false;
    _isInHandler = false;
    _isPeerClosed = false;
  }

  void bindFromHandle(Handle handle) {
    if (isBound) {
      throw new FidlApiError("FidlEventHandler is already bound.");
    }
    _channel = new Channel(handle);
    _subscription = new FidlEventSubscription(handle, _kSignals);
    _isOpen = false;
    _isInHandler = false;
    _isPeerClosed = false;
  }

  void beginHandlingEvents() {
    if (!isBound) {
      throw new FidlApiError("FidlEventHandler is unbound.");
    }
    if (_isOpen) {
      throw new FidlApiError("FidlEventHandler is already handling events");
    }
    _isOpen = true;
    _subscription.subscribe(_tryHandleEvent);
  }

  /// [endHandlineEvents] unsubscribes from the underlying
  /// [FidlEventSubscription].
  void endHandlingEvents() {
    if (!isBound || !_isOpen || _isInHandler) {
      throw new FidlApiError(
          "FidlEventHandler was not handling events when instructed to end");
    }
    if (_isInHandler) {
      throw new FidlApiError(
          "Cannot end handling events from inside a callback");
    }
    _isOpen = false;
    _subscription.unsubscribe();
  }

  /// [unbind] stops handling events, and returns the underlying
  /// [Channel]. The pipe can then be rebound to the same or different
  /// [FidlEventHandler], or closed. [unbind] cannot be called from within
  /// [handleRead] or [handleWrite].
  Channel unbind() {
    if (!isBound) {
      throw new FidlApiError(
          "FidlEventHandler was not bound in call in unbind()");
    }
    if (_isOpen) {
      endHandlingEvents();
    }
    if (_isInHandler) {
      throw new FidlApiError(
          "Cannot unbind a FidlEventHandler from inside a callback.");
    }
    Channel boundchannel = _channel;
    _channel = null;
    _subscription = null;
    return boundchannel;
  }

  Future close({bool immediate: false}) {
    var result;
    _isOpen = false;
    _channel = null;
    if (_subscription != null) {
      result = _subscription
          ._close(immediate: immediate, local: _isPeerClosed)
          .then((_) {
        _subscription = null;
      });
    }
    return result != null ? result : new Future.value(null);
  }

  @override
  String toString() => "FidlEventHandler("
      "isOpen: $_isOpen, isBound: $isBound, channel: $_channel)";

  void _tryHandleEvent(int event) {
    // This callback is running in the handler for a RawReceivePort. All
    // exceptions rethrown or not caught here will be unhandled exceptions in
    // the root zone, bringing down the whole app. An app should rather have an
    // opportunity to handle exceptions coming from Mojo, like the
    // FidlCodecError.
    // TODO(zra): Rather than hard-coding a list of exceptions that bypass the
    // onError callback and are rethrown, investigate allowing an implementer to
    // provide a filter function (possibly initialized with a sensible default).
    try {
      _handleEvent(event);
    } on Error catch (_) {
      // An Error exception from the core libraries is probably a programming
      // error that can't be handled. We rethrow the error so that
      // FidlEventHandlers can't swallow it by mistake.
      rethrow;
    } catch (e, s) {
      close(immediate: true).then((_) {
        if (onError != null) {
          onError(new FidlEventHandlerError(e, s));
        }
      });
    }
  }

  void _handleEvent(int pendingSignals) {
    if (!_isOpen) {
      // The actual close of the underlying stream happens asynchronously
      // after the call to close. However, we start to ignore incoming events
      // immediately.
      return;
    }
    _isInHandler = true;
    if ((pendingSignals & MX_SIGNAL_READABLE) != 0) {
      handleRead();
      _subscription.wait();
    } else if ((pendingSignals & MX_SIGNAL_PEER_CLOSED) != 0) {
      _isPeerClosed = true;
    }
    _isInHandler = false;
    if (_isPeerClosed) {
      close().then((_) {
        if (onError != null) {
          onError(null);
        }
      });
    }
  }
}
